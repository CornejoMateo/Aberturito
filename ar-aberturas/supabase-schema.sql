create table if not exists public.profiles (
  id bigint generated by default as identity not null,
  created_at timestamp with time zone not null default now(),
  category character varying not null,
  code character varying not null,
  line character varying not null,
  color character varying not null,
  status character varying not null,
  quantity smallint not null,
  site character varying not null,
  width numeric not null,
  material character varying not null,
  image_url text null,
  image_path text null,
  last_update timestamp with time zone null,
  constraint profiles_pkey primary key (id),
  constraint quantity_positive check ((quantity >= 0)),
  constraint width_range check ((width > (0)::numeric))
) TABLESPACE pg_default;

create table if not exists public.lines (
  id bigint generated by default as identity not null,
  created_at timestamp with time zone not null default now(),
  name_line character varying not null,
  opening character varying not null,
  constraint Lines_pkey primary key (id),
  constraint lines_name_line_key unique (name_line),
  constraint opening_valid check (
    (
      (opening)::text = any (
        (
          array[
            'Aluminio'::character varying,
            'PVC'::character varying
          ]
        )::text[]
      )
    )
  )
) TABLESPACE pg_default;

create table if not exists public.colors (
  id bigint generated by default as identity not null,
  created_at timestamp with time zone not null default now(),
  line_name character varying not null,
  name_color character varying not null,
  constraint colors_pkey primary key (id),
  constraint colors_color_line_unique unique (name_color, line_name),
  constraint colors_line_name_fkey foreign KEY (line_name) references lines (name_line) on update CASCADE
) TABLESPACE pg_default;

create table public.codes (
  id bigint generated by default as identity not null,
  created_at timestamp with time zone not null default now(),
  name_code character varying not null,
  line_name character varying null,
  constraint codes_pkey primary key (id),
  constraint codes_name_line_unique unique (name_code, line_name),
  constraint codes_line_name_fkey foreign KEY (line_name) references lines (name_line) on update CASCADE
) TABLESPACE pg_default;

create table if not exists public.sites (
  id bigint generated by default as identity not null,
  created_at timestamp with time zone not null default now(),
  name_site character varying not null,
  constraint sites_pkey primary key (id),
  constraint sites_name_site_key unique (name_site)
) TABLESPACE pg_default;


create table if not exists public.ironworks_category (
  id bigint generated by default as identity not null,
  created_at timestamp with time zone not null default now(),
  ironwork_line character varying null,
  ironwork_code character varying not null,
  ironwork_description character varying null,
  ironwork_color character varying not null,
  ironwork_quantity_for_lump bigint not null,
  ironwork_quantity_lump bigint not null,
  ironwork_quantity bigint not null,
  ironwork_site character varying not null,
  image_url character varying null,
  image_path character varying null,
  ironwork_material character varying not null,
  ironwork_price numeric(10, 2) null,
  ironwork_category character varying not null,
  last_update timestamp without time zone null,
  ironwork_brand character varying null,
  constraint ironworks_category_pkey primary key (id),
  constraint chk_ironwork_price_non_negative check ((ironwork_price >= (0)::numeric)),
  constraint chk_ironwork_quantity_for_lump_non_negative check ((ironwork_quantity_for_lump >= 0)),
  constraint chk_ironwork_quantity_lump_non_negative check ((ironwork_quantity_lump >= 0)),
  constraint chk_ironwork_quantity_non_negative check ((ironwork_quantity >= 0))
) TABLESPACE pg_default;

create table if not exists public.accesories_category (
  id bigint generated by default as identity not null,
  created_at timestamp with time zone not null default now(),
  accessory_line character varying null,
  accessory_code character varying not null,
  accessory_description character varying null,
  accessory_color character varying not null,
  accessory_quantity_for_lump bigint not null,
  accessory_quantity_lump bigint not null,
  accessory_quantity bigint not null,
  accessory_site character varying not null,
  image_url character varying null,
  image_path character varying null,
  accessory_material character varying not null,
  accessory_price numeric(10, 2) null,
  accessory_category character varying not null,
  last_update timestamp without time zone null,
  accessory_brand character varying null,
  constraint accesories_category_pkey primary key (id),
  constraint chk_accessory_price_non_negative check ((accessory_price >= (0)::numeric)),
  constraint chk_accessory_quantity_for_lump_non_negative check ((accessory_quantity_for_lump >= 0)),
  constraint chk_accessory_quantity_lump_non_negative check ((accessory_quantity_lump >= 0)),
  constraint chk_accessory_quantity_non_negative check ((accessory_quantity >= 0))
) TABLESPACE pg_default;

create table public.supplies_category (
  id bigint generated by default as identity not null,
  created_at timestamp with time zone not null default now(),
  supply_line character varying null,
  supply_code character varying not null,
  supply_description character varying null,
  supply_color character varying not null,
  supply_quantity_for_lump bigint not null,
  supply_quantity_lump bigint not null,
  supply_quantity bigint not null,
  supply_site character varying not null,
  image_url character varying null,
  image_path character varying null,
  supply_material character varying not null,
  supply_price numeric(10, 2) null,
  supply_category character varying not null,
  last_update timestamp without time zone null,
  supply_brand character varying null,
  constraint supplies_category_pkey primary key (id),
  constraint chk_supply_price_non_negative check ((supply_price >= (0)::numeric)),
  constraint chk_supply_quantity_for_lump_non_negative check ((supply_quantity_for_lump >= 0)),
  constraint chk_supply_quantity_lump_non_negative check ((supply_quantity_lump >= 0)),
  constraint chk_supply_quantity_non_negative check ((supply_quantity >= 0))
) TABLESPACE pg_default;

create table public.clients (
  id bigint generated by default as identity not null,
  created_at timestamp with time zone not null default now(),
  name character varying not null,
  last_name character varying not null,
  phone_number character varying null,
  locality character varying null,
  email character varying null,
  notes text[] null,
  cover text null,
  constraint clients_pkey primary key (id)
) TABLESPACE pg_default;

{/*
  RECORDAR LOS BUCKETS
*/}

create table public.works (
  id bigint generated by default as identity not null,
  created_at timestamp with time zone not null default now(),
  locality character varying null,
  address character varying null,
  client_id bigint null,
  status character varying null,
  architect character varying null,
  notes character varying[] null,
  balance_id bigint null,  constraint works_pkey primary key (id),
  constraint works_client_id_fkey foreign KEY (client_id) references clients (id) on update CASCADE
) TABLESPACE pg_default;

create table public.events (
  id bigint generated by default as identity not null,
  created_at timestamp with time zone not null default now(),
  type character varying null,
  description character varying null,
  title character varying null,
  client character varying null,
  location character varying null,
  date date null,
  address character varying null,
  status character varying null,
  is_overdue boolean null default false,
  constraint events_pkey primary key (id)
) TABLESPACE pg_default;

{/* 
  Para los eventos, correr en SQL editor de Supabase:
*/}

SELECT * FROM pg_extension WHERE extname = 'pg_cron';

CREATE EXTENSION IF NOT EXISTS pg_cron;

UPDATE public.events
SET is_overdue = true
WHERE date < CURRENT_DATE
  AND status = 'Pendiente'
  AND is_overdue = false;

SELECT cron.schedule(
  'mark-overdue-events',
  '5 0 * * *',
  $$
  UPDATE public.events
  SET is_overdue = true
  WHERE date < CURRENT_DATE
    AND status = 'Pendiente'
    AND is_overdue = false;
  $$
);

SELECT jobid, jobname, schedule
FROM cron.job;

create table public.checklists (
  id bigint generated by default as identity not null,
  created_at timestamp with time zone not null default now(),
  work_id bigint null,
  items jsonb null,
  description character varying null,
  progress bigint null,
  name character varying null,
  type_opening character varying null,
  width double precision null,
  height double precision null,
  notes text null,
  constraint checklists_pkey primary key (id),
  constraint checklists_work_id_fkey foreign KEY (work_id) references works (id) on update CASCADE
) TABLESPACE pg_default;
  
create table public.users (
  id bigint generated by default as identity not null,
  username character varying not null,
  role character varying not null,
  password character varying not null,
  constraint users_pkey primary key (id),
  constraint users_username_key unique (username)
) TABLESPACE pg_default;

create table public.balances (
  id bigint generated by default as identity not null,
  created_at timestamp with time zone not null default now(),
  start_date date null,
  budget bigint null,
  contract_date_usd numeric null,
  client_id bigint null,
  notes text[] null,
  work_id bigint null,
  constraint balances_pkey primary key (id),
  constraint balances_client_id_fkey foreign KEY (client_id) references clients (id) on update CASCADE on delete CASCADE,
  constraint balances_work_id_fkey foreign KEY (work_id) references works (id) on update CASCADE on delete CASCADE
) TABLESPACE pg_default;

create table public.balance_transactions (
  id bigint generated by default as identity not null,
  created_at timestamp with time zone not null default now(),
  balance_id bigint null,
  date date null,
  amount numeric null,
  quote_usd numeric null,
  notes text null,
  payment_method character varying null,
  usd_amount numeric null,
  constraint balance_transactions_pkey primary key (id),
  constraint balance_transactions_balance_id_fkey foreign KEY (balance_id) references balances (id) on update CASCADE on delete CASCADE
) TABLESPACE pg_default;

CREATE TABLE IF NOT EXISTS notification_settings (
    id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
    enabled BOOLEAN DEFAULT true NOT NULL,
    emails TEXT[] DEFAULT '{}' NOT NULL,
    time TEXT DEFAULT '09:00' NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL
);

CREATE TABLE IF NOT EXISTS event_filters (
    id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
    settings_id UUID REFERENCES notification_settings(id) ON DELETE CASCADE NOT NULL,
    type TEXT NOT NULL CHECK (type IN ('type', 'title')),
    value TEXT NOT NULL,
    enabled BOOLEAN DEFAULT true NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL
);

CREATE TABLE IF NOT EXISTS email_notifications (
    id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
    settings_id UUID REFERENCES notification_settings(id) ON DELETE CASCADE NOT NULL,
    event_id BIGINT REFERENCES events(id) ON DELETE CASCADE NOT NULL,
    sent_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL,
    status TEXT NOT NULL CHECK (status IN ('pending', 'sent', 'failed')),
    error_message TEXT
);

CREATE INDEX IF NOT EXISTS idx_notification_settings_enabled ON notification_settings(enabled);
CREATE INDEX IF NOT EXISTS idx_event_filters_settings_id ON event_filters(settings_id);
CREATE INDEX IF NOT EXISTS idx_event_filters_enabled ON event_filters(enabled);
CREATE INDEX IF NOT EXISTS idx_email_notifications_settings_id ON email_notifications(settings_id);
CREATE INDEX IF NOT EXISTS idx_email_notifications_event_id ON email_notifications(event_id);
CREATE INDEX IF NOT EXISTS idx_email_notifications_sent_at ON email_notifications(sent_at);

CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = timezone('utc'::text, now());
    RETURN NEW;
END;
$$ language 'plpgsql';

CREATE TRIGGER update_notification_settings_updated_at 
    BEFORE UPDATE ON notification_settings 
    FOR EACH ROW 
    EXECUTE FUNCTION update_updated_at_column();


ALTER TABLE notification_settings ENABLE ROW LEVEL SECURITY;
ALTER TABLE event_filters ENABLE ROW LEVEL SECURITY;
ALTER TABLE email_notifications ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Enable all operations on notification_settings" ON notification_settings
    FOR ALL USING (true);

CREATE POLICY "Enable all operations on event_filters" ON event_filters
    FOR ALL USING (true);

CREATE POLICY "Enable all operations on email_notifications" ON email_notifications
    FOR ALL USING (true);
